## exercise 13.1

拷贝构造函数首先是一个构造函数，然后该函数的第一个形参类型是自身类类型的引用，其他形参都有默认实参。

当编译器通过拷贝初始化生成一个类类型对象时，会调用拷贝构造函数。

## exercise 13.2

拷贝构造函数的第一个形参必须是自身类类型的引用，且最好是`const`。

## exercise 13.3

因为这两个类的成员都是由标准库或`C++`定义的，它们都实现了自己的拷贝控制成员，所以合成的默认构造函数是可以使用的。

合成的默认构造函数会依次拷贝所有类成员。

## exercise 13.4

1. `foo_bar`的形参初始化。

2. `local`的初始化。

3. 动态分配内存以生成一个`Point`类型时。

4. 5. 使用列表初始化时。

6. `foo_bar`返回时。

## exercise 13.5

``` c++
HasPtr(const HasPtr &item)
    : ps(new string(*item.ps)), i(item.i)
{}
```

## exercise 13.6

拷贝赋值运算符定义了当使用一个类类型对象对另一个类类型对象赋值时所执行的操作。

正如定义所言，当对一个类类型对象赋值时会调用拷贝赋值运算符。

合成的拷贝赋值运算符在可行的情况下，会依次赋值类的每个成员。

如果类未定义自己的拷贝赋值运算符，编译器会生成一个合成的拷贝赋值运算符。

## exercise 13.7

因为两个类的成员都定义了拷贝赋值运算符，所以类的赋值会将每个成员都进行赋值。

## exercise 13.8

``` c++
HasPtr& operator=(const HasPtr &item)
{
    delete this->ps;
    ps = new string(*item.ps);
    i = item.i;
    return *this;
}
```

## exercise 13.9

析构函数定义了当对象被销毁时做什么。

合成析构函数什么都不做，只会在析构部分销毁每个成员。

当类未定义自己的析构函数时，编译器会生成一个合成的析构函数。

## exercise 13.10

会调用`shared_ptr`和`weak_ptr`的析构函数。

## exercise 13.11

``` c++
~HasPtr
{
    delete ps;
}
```

## exercise 13.12

三次。

1. 形参`accum`销毁时。

2. 局部变量`item1`销毁时。

3. 局部变量`item2`销毁时。

## [exercise 13.13](./13_13.cc)

我经常忽略的一个地方就是函数返回时会进行拷贝，生成一个临时对象（匿名对象），而这个临时对象也会进行析构。因为是匿名的，所以如果不仔细的话比较容易忽视。